<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Solar System Simulation - True Real Positions</title>
<style>
body {
    margin: 0;
    overflow: hidden;
    background-color: black;
    font-family: Arial, sans-serif;
    color: white;
}

canvas {
    display: block;
}

#clock {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 18px;
    background: rgba(0,0,0,0.5);
    padding: 6px 12px;
    border-radius: 6px;
    user-select: none;
}

#controls {
    position: absolute;
    top: 50px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 6px;
    font-size: 14px;
}

#controls button {
    background: rgba(255,255,255,0.2);
    color: white;
    border: 1px solid white;
    padding: 5px 10px;
    margin: 2px;
    cursor: pointer;
    border-radius: 4px;
}

#controls button:hover {
    background: rgba(255,255,255,0.4);
}

#controls button.active {
    background: rgba(100,200,100,0.5);
    border-color: lightgreen;
}

#info {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    max-width: 250px;
}

#fps {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 14px;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="clock"></div>
<div id="controls">
    <div><strong>Controls:</strong></div>
    <button onclick="adjustSpeed(0.5)">0.5x</button>
    <button onclick="adjustSpeed(1)">1x</button>
    <button onclick="adjustSpeed(2)">2x</button>
    <button onclick="adjustSpeed(5)">5x</button>
    <button onclick="adjustSpeed(10)">10x</button>
    <div style="margin-top:5px">
        <button onclick="adjustZoom(-0.2)">Zoom -</button>
        <button onclick="resetView()">Reset</button>
        <button onclick="adjustZoom(0.2)">Zoom +</button>
    </div>
    <div style="margin-top:5px">
        <button onclick="toggleTrails()">Toggle Trails</button>
        <button onclick="toggleLabels()">Toggle Labels</button>
    </div>
    <div style="margin-top:5px">
        <button onclick="togglePause()">‚èØ Pause/Resume</button>
    </div>
    <div style="margin-top:5px">
        <button id="realTimeBtn" onclick="toggleRealTime()">üåç Real Time Mode</button>
    </div>
</div>
<div id="fps">FPS: 60</div>
<div id="info">
    Click and drag to pan<br>
    Mouse wheel to zoom<br>
    Real Time uses NASA orbital elements
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { alpha: false });

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let centerX = canvas.width/2;
let centerY = canvas.height/2;

// Performance optimizations
let showTrails = true;
let showLabels = true;
let isPaused = false;
let speedMultiplier = 1;
let isRealTimeMode = false;

// Zoom and pan
let zoom = 1;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;

// FPS counter
let fps = 60;
let frameCount = 0;
let lastFpsUpdate = Date.now();

// Stars - optimized with pre-calculated positions
const stars = [];
for(let i=0;i<300;i++){
    stars.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        radius: Math.random()*1.5,
        alpha: Math.random(),
        alphaChange: (Math.random()-0.5)*0.02
    });
}

// Scale factor - AU to pixels
const AU = 80; // 1 AU = 80 pixels

// Sun
const sun = { 
    x: centerX, 
    y: centerY, 
    radius: 25, 
    color: "yellow",
    name: "Sun",
    info: "The Sun is the star at the center of our Solar System"
};

// Orbital elements for planets (epoch J2000.0)
// Format: [a (AU), e, I (deg), L (deg), longPeri (deg), longNode (deg)]
// with century rates [da, de, dI, dL, dlongPeri, dlongNode]
const orbitalElements = {
    Mercury: {
        elements: [0.38709927, 0.20563593, 7.00497902, 252.25032350, 77.45779628, 48.33076593],
        rates: [0.00000037, 0.00001906, -0.00594749, 149472.67411175, 0.16047689, -0.12534081]
    },
    Venus: {
        elements: [0.72333566, 0.00677672, 3.39467605, 181.97909950, 131.60246718, 76.67984255],
        rates: [0.00000390, -0.00004107, -0.00078890, 58517.81538729, 0.00268329, -0.27769418]
    },
    Earth: {
        elements: [1.00000261, 0.01671123, -0.00001531, 100.46457166, 102.93768193, 0.0],
        rates: [0.00000562, -0.00004392, -0.01294668, 35999.37244981, 0.32327364, 0.0]
    },
    Mars: {
        elements: [1.52371034, 0.09339410, 1.84969142, -4.55343205, -23.94362959, 49.55953891],
        rates: [0.00001847, 0.00007882, -0.00813131, 19140.30268499, 0.44441088, -0.29257343]
    },
    Jupiter: {
        elements: [5.20288700, 0.04838624, 1.30439695, 34.39644051, 14.72847983, 100.47390909],
        rates: [-0.00011607, -0.00013253, -0.00183714, 3034.74612775, 0.21252668, 0.20469106]
    },
    Saturn: {
        elements: [9.53667594, 0.05386179, 2.48599187, 49.95424423, 92.59887831, 113.66242448],
        rates: [-0.00125060, -0.00050991, 0.00193609, 1222.49362201, -0.41897216, -0.28867794]
    },
    Uranus: {
        elements: [19.18916464, 0.04725744, 0.77263783, 313.23810451, 170.95427630, 74.01692503],
        rates: [-0.00196176, -0.00004397, -0.00242939, 428.48202785, 0.40805281, 0.04240589]
    },
    Neptune: {
        elements: [30.06992276, 0.00859048, 1.77004347, -55.12002969, 44.96476227, 131.78422574],
        rates: [0.00026291, 0.00005105, 0.00035372, 218.45945325, -0.32241464, -0.00508664]
    }
};

// Planets data structure
const planets = [
    { name:"Mercury", radius:4, color:"gray", trail:[], x:0, y:0, angle:0, info:"Smallest planet, closest to Sun" },
    { name:"Venus", radius:6, color:"orange", trail:[], x:0, y:0, angle:0, info:"Hottest planet, thick atmosphere" },
    { name:"Earth", radius:8, color:"blue", trail:[], x:0, y:0, angle:0, info:"Our home planet, has life" },
    { name:"Mars", radius:7, color:"red", trail:[], x:0, y:0, angle:0, info:"The Red Planet, has 2 moons" },
    { name:"Jupiter", radius:12, color:"orange", trail:[], x:0, y:0, angle:0, info:"Largest planet, gas giant" },
    { name:"Saturn", radius:10, color:"gold", trail:[], x:0, y:0, angle:0, hasRings: true, info:"Famous for its rings" },
    { name:"Uranus", radius:9, color:"lightblue", trail:[], x:0, y:0, angle:0, info:"Ice giant, rotates on its side" },
    { name:"Neptune", radius:9, color:"blue", trail:[], x:0, y:0, angle:0, info:"Farthest planet, dark and cold" }
];

// Asteroid belt - reduced for performance
const asteroids = [];
for(let i=0;i<200;i++){
    const distX = Math.random()*0.5*AU + 2.2*AU;
    const angle = Math.random()*Math.PI*2;
    const speed = 0.01 + Math.random()*0.01;
    asteroids.push({ distance:distX/AU, angle:angle, speed:speed, radius:1, color:"gray", trail:[] });
}

// Solar System time
let simTimeSeconds = 0;
const baseSimulationSpeed = 3600*24;

// J2000.0 epoch: January 1, 2000, 12:00 TT
const J2000 = new Date('2000-01-01T12:00:00Z').getTime();

// Calculate Julian centuries from J2000
function getJulianCenturies(date) {
    const JD = (date.getTime() / 86400000) + 2440587.5;
    return (JD - 2451545.0) / 36525.0;
}

// Normalize angle to 0-360 degrees
function normalizeAngle(angle) {
    while (angle < 0) angle += 360;
    while (angle > 360) angle -= 360;
    return angle;
}

// Calculate planet position using orbital elements
function calculatePlanetPosition(planetName, T) {
    const elem = orbitalElements[planetName];
    if (!elem) return { x: 0, y: 0 };
    
    // Get orbital elements for this epoch
    let [a, e, I, L, longPeri, longNode] = elem.elements;
    const [da, de, dI, dL, dlongPeri, dlongNode] = elem.rates;
    
    // Update for current epoch
    a += da * T;
    e += de * T;
    I += dI * T;
    L += dL * T;
    longPeri += dlongPeri * T;
    longNode += dlongNode * T;
    
    // Calculate argument of perihelion and mean anomaly
    const omega = longPeri - longNode;
    let M = L - longPeri;
    M = normalizeAngle(M);
    
    // Convert to radians
    const Mrad = M * Math.PI / 180;
    const omegaRad = omega * Math.PI / 180;
    const Irad = I * Math.PI / 180;
    const longNodeRad = longNode * Math.PI / 180;
    
    // Solve Kepler's equation for eccentric anomaly (E)
    let E = Mrad;
    for (let i = 0; i < 10; i++) {
        E = Mrad + e * Math.sin(E);
    }
    
    // Calculate true anomaly
    const nu = 2 * Math.atan2(
        Math.sqrt(1 + e) * Math.sin(E / 2),
        Math.sqrt(1 - e) * Math.cos(E / 2)
    );
    
    // Calculate distance
    const r = a * (1 - e * Math.cos(E));
    
    // Calculate heliocentric coordinates in orbital plane
    const xOrbital = r * Math.cos(nu);
    const yOrbital = r * Math.sin(nu);
    
    // Rotate to ecliptic plane
    const cosOmega = Math.cos(omegaRad);
    const sinOmega = Math.sin(omegaRad);
    const cosI = Math.cos(Irad);
    const sinI = Math.sin(Irad);
    const cosNode = Math.cos(longNodeRad);
    const sinNode = Math.sin(longNodeRad);
    
    const xEcliptic = (cosOmega * cosNode - sinOmega * sinNode * cosI) * xOrbital +
                      (-sinOmega * cosNode - cosOmega * sinNode * cosI) * yOrbital;
    const yEcliptic = (cosOmega * sinNode + sinOmega * cosNode * cosI) * xOrbital +
                      (-sinOmega * sinNode + cosOmega * cosNode * cosI) * yOrbital;
    
    return { x: xEcliptic * AU, y: yEcliptic * AU, r: r };
}

function updateSimTime(){
    if(isPaused) return;
    
    if(isRealTimeMode){
        // Use actual current date/time
        const now = new Date();
        const diffMs = now.getTime() - J2000;
        simTimeSeconds = diffMs / 1000;
        
        const seconds = now.getSeconds();
        const minutes = now.getMinutes();
        const hours = now.getHours();
        const days = now.getDate();
        const months = now.getMonth() + 1;
        const years = now.getFullYear();
        
        document.getElementById("clock").innerText =
            `üåç REAL TIME: ${years}-${months.toString().padStart(2,'0')}-${days.toString().padStart(2,'0')} `+
            `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
    } else {
        simTimeSeconds += baseSimulationSpeed * speedMultiplier;
        const seconds = Math.floor(simTimeSeconds%60);
        const minutes = Math.floor((simTimeSeconds/60)%60);
        const hours = Math.floor((simTimeSeconds/3600)%24);
        const days = Math.floor((simTimeSeconds/(3600*24))%365)+1;
        const months = Math.floor(days/30)+1;
        const years = Math.floor(simTimeSeconds/(3600*24*365))+2000;

        document.getElementById("clock").innerText =
            `Year ${years}, Month ${months}, Day ${days}, `+
            `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')} (${speedMultiplier}x)`;
    }
}

// Draw stars - optimized
function drawStars(){
    for(let i=0; i<stars.length; i++){
        const s = stars[i];
        ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
        ctx.fillRect(s.x-s.radius, s.y-s.radius, s.radius*2, s.radius*2);
        
        s.alpha += s.alphaChange;
        if(s.alpha>1){ s.alpha=1; s.alphaChange = -Math.abs(s.alphaChange); }
        if(s.alpha<0){ s.alpha=0; s.alphaChange = Math.abs(s.alphaChange); }
    }
}

// Optimized trail rendering
function drawTrail(trail, color, width){
    if(!showTrails || trail.length < 2) return;
    
    ctx.beginPath();
    ctx.moveTo(trail[0].x, trail[0].y);
    for(let i=1; i<trail.length; i++){
        ctx.lineTo(trail[i].x, trail[i].y);
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.stroke();
}

// Draw function - optimized
function draw(){
    // Clear with black background
    ctx.fillStyle="black";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawStars();

    // Disable shadows for better performance
    ctx.shadowBlur = 0;

    // Sun
    ctx.fillStyle=sun.color;
    ctx.beginPath();
    ctx.arc(centerX + offsetX, centerY + offsetY, sun.radius*zoom, 0, Math.PI*2);
    ctx.fill();

    // Planets
    for(let i=0; i<planets.length; i++){
        const p = planets[i];
        const px = centerX + offsetX + p.x*zoom;
        const py = centerY + offsetY + p.y*zoom;

        // Trail
        if(showTrails){
            p.trail.push({x:px,y:py});
            if(p.trail.length>300) p.trail.shift();
            drawTrail(p.trail, p.color, 1.5);
        }

        // Saturn's rings
        if(p.hasRings){
            ctx.strokeStyle = "rgba(255,215,0,0.5)";
            ctx.lineWidth = 3*zoom;
            ctx.beginPath();
            ctx.ellipse(px, py, p.radius*2*zoom, p.radius*1.2*zoom, 0, 0, Math.PI*2);
            ctx.stroke();
        }

        // Planet
        ctx.fillStyle=p.color;
        ctx.beginPath();
        ctx.arc(px,py,p.radius*zoom,0,Math.PI*2);
        ctx.fill();

        // Label
        if(showLabels){
            ctx.fillStyle="white";
            ctx.font=`${12*zoom}px Arial`;
            ctx.fillText(p.name, px + 10*zoom, py - 10*zoom);
        }
    }

    // Asteroids - batch rendering
    ctx.fillStyle="gray";
    for(let i=0; i<asteroids.length; i++){
        const a = asteroids[i];
        const ax = centerX + offsetX + a.distance*AU*Math.cos(a.angle)*zoom;
        const ay = centerY + offsetY + a.distance*AU*Math.sin(a.angle)*zoom;

        if(showTrails){
            a.trail.push({x:ax,y:ay});
            if(a.trail.length>50) a.trail.shift();
            drawTrail(a.trail, a.color, 0.8);
        }

        ctx.beginPath();
        ctx.arc(ax,ay,a.radius*zoom,0,Math.PI*2);
        ctx.fill();
    }
}

// Update function - optimized
function update(){
    if(isPaused) return;
    
    if(isRealTimeMode){
        // Calculate current Julian centuries from J2000
        const now = new Date();
        const T = getJulianCenturies(now);
        
        // Update all planet positions using real orbital mechanics
        for(let i=0; i<planets.length; i++){
            const pos = calculatePlanetPosition(planets[i].name, T);
            planets[i].x = pos.x;
            planets[i].y = pos.y;
        }
    } else {
        // Simulation mode - use approximate date
        const simDate = new Date(J2000 + simTimeSeconds * 1000);
        const T = getJulianCenturies(simDate);
        
        // Update all planet positions
        for(let i=0; i<planets.length; i++){
            const pos = calculatePlanetPosition(planets[i].name, T);
            planets[i].x = pos.x;
            planets[i].y = pos.y;
        }
    }
    
    // Update asteroids (simple circular orbits)
    const effectiveSpeed = isRealTimeMode ? 0.00001 : speedMultiplier * 0.01;
    for(let i=0; i<asteroids.length; i++){
        asteroids[i].angle += asteroids[i].speed * effectiveSpeed;
    }
}

// FPS counter
function updateFPS(){
    frameCount++;
    const now = Date.now();
    if(now - lastFpsUpdate >= 1000){
        fps = frameCount;
        document.getElementById("fps").innerText = `FPS: ${fps}`;
        frameCount = 0;
        lastFpsUpdate = now;
    }
}

// Animation loop
function animate(){
    update();
    draw();
    updateSimTime();
    updateFPS();
    requestAnimationFrame(animate);
}

animate();

// Controls
function adjustSpeed(multiplier){
    speedMultiplier = multiplier;
}

function adjustZoom(delta){
    zoom = Math.max(0.1, Math.min(5, zoom + delta));
}

function resetView(){
    zoom = 1;
    offsetX = 0;
    offsetY = 0;
}

function toggleTrails(){
    showTrails = !showTrails;
    if(!showTrails){
        planets.forEach(p=>{ p.trail=[]; });
        asteroids.forEach(a=>a.trail=[]);
    }
}

function toggleLabels(){
    showLabels = !showLabels;
}

function togglePause(){
    isPaused = !isPaused;
}

function toggleRealTime(){
    isRealTimeMode = !isRealTimeMode;
    const btn = document.getElementById('realTimeBtn');
    if(isRealTimeMode){
        btn.classList.add('active');
        // Sync to current real time immediately
        const now = new Date();
        simTimeSeconds = (now.getTime() - J2000) / 1000;
    } else {
        btn.classList.remove('active');
    }
}

// Mouse controls
canvas.addEventListener('mousedown', (e)=>{
    isDragging = true;
    dragStartX = e.clientX - offsetX;
    dragStartY = e.clientY - offsetY;
});

canvas.addEventListener('mousemove', (e)=>{
    if(isDragging){
        offsetX = e.clientX - dragStartX;
        offsetY = e.clientY - dragStartY;
    }
});

canvas.addEventListener('mouseup', ()=>{
    isDragging = false;
});

canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    adjustZoom(delta);
});

// Resize
window.addEventListener("resize", ()=>{
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    centerX = canvas.width/2;
    centerY = canvas.height/2;
});
</script>
</body>
</html>
